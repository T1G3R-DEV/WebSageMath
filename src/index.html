<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>WebSageMath</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    body, html { margin: 0; height: 100%; }
    #splitter { cursor: col-resize; width: 4px; background-color: #ccc; }
  </style>
</head>
<body class="h-screen flex flex-col">

  <!-- Header -->
  <header class="bg-gray-800 text-white flex items-center p-4">
    <h1 class="text-xl font-bold">WebSageMath</h1>
  </header>

  <!-- Main area: resizable sidebar + canvas -->
  <main class="flex flex-1 overflow-hidden">

    <!-- Sidebar -->
    <aside id="sidebar" class="bg-gray-200 min-w-[50px] max-w-[500px] w-64 p-2 overflow-y-auto relative transition-all duration-300 ease-in-out">
      <button id="toggle-sidebar" class="absolute top-2 right-2 text-gray-600 hover:text-black focus:outline-none">
        <svg id="toggle-icon" class="w-5 h-5" fill="none" stroke="currentColor" stroke-width="2"
             viewBox="0 0 24 24">
          <path stroke-linecap="round" stroke-linejoin="round" d="M18 12H6"/>
        </svg>
      </button>
      <h2 class="text-lg font-semibold mb-2">Elements</h2>
      <div id="elements-list" class="flex flex-col gap-2">
        <!-- Example elements -->
        <div class="flex items-center gap-1">
          <input type="checkbox" checked class="draw-toggle"/>
          <span class="text-gray-600"><svg class="w-4 h-4 inline" fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24"><circle cx="12" cy="12" r="2"/></svg></span>
          <input type="text" class="flex-1 p-1 border rounded text-sm" value="Point A"/>
        </div>
        <div class="flex items-center gap-1">
          <input type="checkbox" checked class="draw-toggle"/>
          <span class="text-gray-600"><svg class="w-4 h-4 inline" fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24"><line x1="4" y1="12" x2="20" y2="12"/></svg></span>
          <input type="text" class="flex-1 p-1 border rounded text-sm" value="Line AB"/>
        </div>
      </div>
    </aside>

    <!-- Splitter -->
    <div id="splitter"></div>

    <!-- Canvas -->
    <div class="flex-1 relative bg-white">
      <canvas id="geometry-canvas" class="w-full h-full touch-none"></canvas>
    </div>

  </main>

  <!-- Footer -->
  <footer class="bg-gray-800 text-white text-center text-sm p-2">&copy; 2025 T1G3R.dev</footer>

  <script>
    const sidebar = document.getElementById('sidebar');
    const splitter = document.getElementById('splitter');
    let isResizing = false;

    splitter.addEventListener('mousedown', () => { isResizing = true; });
    window.addEventListener('mousemove', e => {
      if (!isResizing) return;
      const newWidth = Math.min(Math.max(e.clientX, 50), 900);
      sidebar.style.width = newWidth + 'px';
    });
    window.addEventListener('mouseup', () => isResizing = false);

    const canvas = document.getElementById('geometry-canvas');
    const ctx = canvas.getContext('2d');
    let scale = 1, offsetX = 0, offsetY = 0;
    let isDragging = false, lastX = 0, lastY = 0;

    // requestAnimationFrame batching
    let needsRedraw = false;
    function requestDraw() {
      if (!needsRedraw) {
        needsRedraw = true;
        requestAnimationFrame(() => {
          draw();
          needsRedraw = false;
        });
      }
    }

    function resizeCanvas() {
      canvas.width = canvas.clientWidth;
      canvas.height = canvas.clientHeight;
      requestDraw();
    }

    function draw() {
      ctx.setTransform(scale, 0, 0, scale, offsetX, offsetY);
      ctx.clearRect(-offsetX/scale, -offsetY/scale, canvas.width/scale, canvas.height/scale);

      // Grid
      const gridSize = 30;
      ctx.strokeStyle = "#e2e8f0";
      ctx.lineWidth = 1/scale;
      const startX = Math.floor((-offsetX/scale)/gridSize)*gridSize;
      const startY = Math.floor((-offsetY/scale)/gridSize)*gridSize;

      for (let x = startX; x < (canvas.width/scale - offsetX/scale); x += gridSize) {
        ctx.beginPath(); ctx.moveTo(x, -offsetY/scale); ctx.lineTo(x, (canvas.height-offsetY)/scale); ctx.stroke();
      }
      for (let y = startY; y < (canvas.height/scale - offsetY/scale); y += gridSize) {
        ctx.beginPath(); ctx.moveTo(-offsetX/scale, y); ctx.lineTo((canvas.width-offsetX)/scale, y); ctx.stroke();
      }

      // Elements
      document.querySelectorAll('#elements-list > div').forEach((el, i) => {
        const checkbox = el.querySelector('.draw-toggle');
        const text = el.querySelector('input[type="text"]').value;
        if (!checkbox.checked || !text.trim()) return;
        ctx.fillStyle = 'black';
        ctx.font = `${14/scale}px sans-serif`;
        ctx.fillText(text, 50 + i*20, 50 + i*20);
      });
    }

    canvas.addEventListener('mousedown', e => { isDragging = true; lastX = e.clientX; lastY = e.clientY; });
    window.addEventListener('mousemove', e => {
      if (!isDragging) return;
      offsetX += e.clientX - lastX;
      offsetY += e.clientY - lastY;
      lastX = e.clientX; lastY = e.clientY;
      requestDraw();
    });
    window.addEventListener('mouseup', () => isDragging = false);

    canvas.addEventListener('wheel', e => {
      e.preventDefault();
      const scaleAmount = -e.deltaY * 0.001;
      const newScale = Math.min(Math.max(0.1, scale * (1 + scaleAmount)), 10);
      const mx = e.offsetX, my = e.offsetY;
      const wx = (mx - offsetX) / scale, wy = (my - offsetY) / scale;
      offsetX = mx - wx * newScale;
      offsetY = my - wy * newScale;
      scale = newScale;
      requestDraw();
    }, {passive: false});

    let lastTouchDist = null;
    canvas.addEventListener('touchstart', e => {
      if (e.touches.length === 1) {
        isDragging = true;
        lastX = e.touches[0].clientX;
        lastY = e.touches[0].clientY;
      }
      if (e.touches.length === 2) {
        const dx = e.touches[0].clientX - e.touches[1].clientX;
        const dy = e.touches[0].clientY - e.touches[1].clientY;
        lastTouchDist = Math.sqrt(dx*dx + dy*dy);
      }
    }, {passive: false});
    canvas.addEventListener('touchmove', e => {
      e.preventDefault();
      if (e.touches.length === 1 && isDragging) {
        offsetX += e.touches[0].clientX - lastX;
        offsetY += e.touches[0].clientY - lastY;
        lastX = e.touches[0].clientX; lastY = e.touches[0].clientY;
        requestDraw();
      }
      if (e.touches.length === 2) {
        const dx = e.touches[0].clientX - e.touches[1].clientX;
        const dy = e.touches[0].clientY - e.touches[1].clientY;
        const dist = Math.sqrt(dx*dx + dy*dy);
        if (lastTouchDist) {
          const scaleFactor = dist / lastTouchDist;
          const newScale = Math.min(Math.max(0.1, scale * scaleFactor), 10);
          const mx = (e.touches[0].clientX + e.touches[1].clientX)/2;
          const my = (e.touches[0].clientY + e.touches[1].clientY)/2;
          const wx = (mx - offsetX) / scale, wy = (my - offsetY) / scale;
          offsetX = mx - wx * newScale;
          offsetY = my - wy * newScale;
          scale = newScale;
          requestDraw();
        }
        lastTouchDist = dist;
      }
    }, {passive: false});
    window.addEventListener('touchend', () => { isDragging = false; lastTouchDist = null; });

    window.addEventListener('resize', resizeCanvas);
    window.addEventListener('load', resizeCanvas);

    function createElement(name = "", icon = "point") {
      const container = document.createElement('div');
      container.className = 'flex items-center gap-1';
      let iconSVG = icon === "line" ?
        `<svg class="w-4 h-4 inline" fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24"><line x1="4" y1="12" x2="20" y2="12"/></svg>` :
        `<svg class="w-4 h-4 inline" fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24"><circle cx="12" cy="12" r="2"/></svg>`;
      container.innerHTML = `
        <input type="checkbox" ${name ? "checked" : ""} class="draw-toggle"/>
        <span class="text-gray-600">${iconSVG}</span>
        <input type="text" class="flex-1 p-1 border rounded text-sm" value="${name}"/>
      `;
      document.getElementById('elements-list').appendChild(container);
    }

    function ensureBlankElement() {
      const elements = document.querySelectorAll('#elements-list > div');
      const lastInput = elements[elements.length - 1]?.querySelector('input[type="text"]');
      if (lastInput && lastInput.value.trim() !== "" && elements.length < 1000) {
        createElement("", "point");
      }
      if (elements.length > 500) console.warn("Sidebar has over 500 elements â€” possible runaway growth.");
    }

    function debounce(func, wait) {
      let timeout;
      return function(...args) {
        clearTimeout(timeout);
        timeout = setTimeout(() => func.apply(this, args), wait);
      };
    }

    const handleElementsChange = debounce(() => {
      requestDraw();
      ensureBlankElement();
    }, 100);

    document.getElementById('elements-list').addEventListener('input', handleElementsChange);
    document.getElementById('elements-list').addEventListener('change', handleElementsChange);

    ensureBlankElement();

    const toggleBtn = document.getElementById('toggle-sidebar');
    const toggleIcon = document.getElementById('toggle-icon');
    let minimized = false;

    toggleBtn.addEventListener('click', () => {
      minimized = !minimized;
      sidebar.style.width = minimized ? '50px' : '250px';
      toggleIcon.innerHTML = minimized
        ? '<path stroke-linecap="round" stroke-linejoin="round" d="M4 12h16"/>'
        : '<path stroke-linecap="round" stroke-linejoin="round" d="M18 12H6"/>';
    });
  </script>
</body>
</html>
