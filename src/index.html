<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Dynamic Geometry App</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    body, html { margin: 0; height: 100%; }
    /* Splitter cursor */
    #splitter { cursor: col-resize; width: 4px; background-color: #ccc; }
  </style>
</head>
<body class="h-screen flex flex-col">

  <!-- Header -->
  <header class="bg-gray-800 text-white p-4 text-center">
    <h1 class="text-xl font-bold">WebSageMath</h1>
  </header>

  <!-- Main area: resizable sidebar + canvas -->
  <main class="flex flex-1 overflow-hidden">

    <!-- Sidebar -->
    <aside id="sidebar" class="bg-gray-200 min-w-[150px] max-w-[500px] w-64 p-2 overflow-y-auto">
      <h2 class="text-lg font-semibold mb-2">Elements</h2>
      <div id="elements-list" class="flex flex-col gap-2">
        <!-- Example element -->
        <div class="flex items-center gap-1">
          <input type="checkbox" checked class="draw-toggle"/>
          <input type="text" class="flex-1 p-1 border rounded text-sm" value="Point A"/>
        </div>
        <div class="flex items-center gap-1">
          <input type="checkbox" checked class="draw-toggle"/>
          <input type="text" class="flex-1 p-1 border rounded text-sm" value="Line AB"/>
        </div>
      </div>
      <button id="add-element" class="mt-4 bg-green-500 hover:bg-green-600 text-white p-2 w-full rounded">Add Element</button>
    </aside>

    <!-- Splitter for resizing sidebar -->
    <div id="splitter"></div>

    <!-- Canvas container -->
    <div class="flex-1 relative bg-white">
      <canvas id="geometry-canvas" class="w-full h-full touch-none"></canvas>
    </div>

  </main>

  <!-- Footer -->
  <footer class="bg-gray-800 text-white text-center text-sm p-2">&copy; 2025 T1G3R.dev</footer>

  <script>
    // Sidebar resizing logic
    const sidebar = document.getElementById('sidebar');
    const splitter = document.getElementById('splitter');
    let isResizing = false;

    splitter.addEventListener('mousedown', e => { isResizing = true; });
    window.addEventListener('mousemove', e => {
      if (!isResizing) return;
      const newWidth = Math.min(Math.max(e.clientX, 150), 500);
      sidebar.style.width = newWidth + 'px';
    });
    window.addEventListener('mouseup', () => isResizing = false);

    // Canvas + zoom/pan logic
    const canvas = document.getElementById('geometry-canvas');
    const ctx = canvas.getContext('2d');
    let scale = 1, offsetX = 0, offsetY = 0;
    let isDragging = false, lastX = 0, lastY = 0;

    function resizeCanvas() {
      canvas.width = canvas.clientWidth;
      canvas.height = canvas.clientHeight;
      draw();
    }

    function draw() {
      ctx.setTransform(scale, 0, 0, scale, offsetX, offsetY);
      ctx.clearRect(-offsetX/scale, -offsetY/scale, canvas.width/scale, canvas.height/scale);

      // Draw grid
      const gridSize = 30;
      ctx.strokeStyle = "#e2e8f0";
      ctx.lineWidth = 1/scale;
      const startX = Math.floor((-offsetX/scale)/gridSize)*gridSize;
      const startY = Math.floor((-offsetY/scale)/gridSize)*gridSize;

      for (let x = startX; x < (canvas.width/scale - offsetX/scale); x += gridSize) {
        ctx.beginPath(); ctx.moveTo(x, -offsetY/scale); ctx.lineTo(x, (canvas.height-offsetY)/scale); ctx.stroke();
      }
      for (let y = startY; y < (canvas.height/scale - offsetY/scale); y += gridSize) {
        ctx.beginPath(); ctx.moveTo(-offsetX/scale, y); ctx.lineTo((canvas.width-offsetX)/scale, y); ctx.stroke();
      }

      // Draw active elements
      document.querySelectorAll('#elements-list > div').forEach((el, i) => {
        const checkbox = el.querySelector('.draw-toggle');
        const text = el.querySelector('input[type="text"]').value;
        if (!checkbox.checked) return;
        ctx.fillStyle = 'black';
        ctx.font = `${14/scale}px sans-serif`;
        ctx.fillText(text, 50 + i*20, 50 + i*20); // example: draw name at offset positions
      });
    }

    canvas.addEventListener('mousedown', e => { isDragging = true; lastX = e.clientX; lastY = e.clientY; });
    window.addEventListener('mousemove', e => {
      if (!isDragging) return;
      const dx = e.clientX - lastX;
      const dy = e.clientY - lastY;
      offsetX += dx;
      offsetY += dy;
      lastX = e.clientX;
      lastY = e.clientY;
      draw();
    });
    window.addEventListener('mouseup', () => isDragging = false);

    canvas.addEventListener('wheel', e => {
      e.preventDefault();
      const scaleAmount = -e.deltaY * 0.001;
      const newScale = Math.min(Math.max(0.1, scale * (1 + scaleAmount)), 10);
      const mx = e.offsetX, my = e.offsetY;
      const wx = (mx - offsetX) / scale, wy = (my - offsetY) / scale;
      offsetX = mx - wx * newScale;
      offsetY = my - wy * newScale;
      scale = newScale;
      draw();
    }, {passive: false});

    // Touch: pan + pinch
    let lastTouchDist = null;
    canvas.addEventListener('touchstart', e => {
      if (e.touches.length === 1) {
        isDragging = true;
        lastX = e.touches[0].clientX;
        lastY = e.touches[0].clientY;
      }
      if (e.touches.length === 2) {
        const dx = e.touches[0].clientX - e.touches[1].clientX;
        const dy = e.touches[0].clientY - e.touches[1].clientY;
        lastTouchDist = Math.sqrt(dx*dx + dy*dy);
      }
    }, {passive: false});
    canvas.addEventListener('touchmove', e => {
      e.preventDefault();
      if (e.touches.length === 1 && isDragging) {
        const dx = e.touches[0].clientX - lastX;
        const dy = e.touches[0].clientY - lastY;
        offsetX += dx; offsetY += dy;
        lastX = e.touches[0].clientX; lastY = e.touches[0].clientY;
        draw();
      }
      if (e.touches.length === 2) {
        const dx = e.touches[0].clientX - e.touches[1].clientX;
        const dy = e.touches[0].clientY - e.touches[1].clientY;
        const dist = Math.sqrt(dx*dx + dy*dy);
        if (lastTouchDist) {
          const scaleFactor = dist / lastTouchDist;
          const newScale = Math.min(Math.max(0.1, scale * scaleFactor), 10);
          const mx = (e.touches[0].clientX + e.touches[1].clientX)/2;
          const my = (e.touches[0].clientY + e.touches[1].clientY)/2;
          const wx = (mx - offsetX) / scale, wy = (my - offsetY) / scale;
          offsetX = mx - wx * newScale;
          offsetY = my - wy * newScale;
          scale = newScale;
          draw();
        }
        lastTouchDist = dist;
      }
    }, {passive: false});
    window.addEventListener('touchend', () => { isDragging = false; lastTouchDist = null; });

    // Update canvas on resize
    window.addEventListener('resize', resizeCanvas);
    window.addEventListener('load', resizeCanvas);

    // Add element button logic
    document.getElementById('add-element').addEventListener('click', () => {
      const container = document.createElement('div');
      container.className = 'flex items-center gap-1';
      container.innerHTML = `
        <input type="checkbox" checked class="draw-toggle"/>
        <input type="text" class="flex-1 p-1 border rounded text-sm" value="New Element"/>
      `;
      document.getElementById('elements-list').appendChild(container);
      draw();
    });

    document.getElementById('elements-list').addEventListener('change', draw);
    document.getElementById('elements-list').addEventListener('input', draw);
  </script>
</body>
</html>
